// Documentation Section
// CECS346Lab6.c
// Course number: CECS 346
// Assignment: Lab 6
// Project Group #10
// Team Members: Jose Ambriz, Bronson Garel, Jonathan Kim, Dylan Ong, Kyle Wyckoff
// Date: 10/18/2024
// System Requirements: 
// 	?

// Hardware design information:
//	?

#include "tm4c123gh6pm.h"
#include <stdint.h> // C99 data types

// 1. Pre-processor Directives Section
// Constant declarations to access port registers using 
// symbolic names instead of addresses

// TODO: define bit addresses for the three LEDs connected to PORTF  DONE
#define LED        (*((volatile uint32_t *)0x40025038)) //adds 0x0038 to base for bits PF1-3
#define SW2        (*((volatile uint32_t *)0x40025004)) //adds 0x0004 to base for first bit  
	
// TODO: Define the three LED bit positions  DONE
#define RED  			0x02  //PF1 bit position
#define BLUE 			0x04  //PF2 bit position
#define GREEN			0x08  //PF3 bit position
#define SW2_MASK  0x00  //PF0 bit position

// TODO: define constants used in this project.
#define HALF_S 							8000000U          // Assume the system clock is 16MHz.
																				// define number of clock cycles to generate 0.5s time interval.
                                        // A U follows a constant indicate this is an unsigned number
																				//Calculation: 16MHz * 0.5s = 8,000,000 ticks
#define NVIC_EN0_PORTF		  0xE000100  // bit position for PORTF interrupt in NVIC_EN0_R register.
															

// Function Prototypes (external functions from startup.s)
extern void DisableInterrupts(void); // Disable interrupts
extern void EnableInterrupts(void);  // Enable interrupts
extern void WaitForInterrupt(void);  // Go to low power mode while waiting for the next interrupt

// Function Prototypes
// Initialize rising edge triggered interrupt for PF0 (SW2) and three LEDs on Port F
void Switch_LED_Init(void);  

// Initialize SysTick timer with interrupt enabled.
// Parameter "period" specifies number of counts for the time 
// period generated by systick timer.
void SysTick_Init(uint32_t period);      

// global variable visible in Watch and Memory window of debugger:
// used for the purpose of practicing debug: use watch window and memory window 
// to keep track of varaible values and memory contents.
// This variable helps keeping track of number of button presses: 
// it increments once per button release.
volatile uint32_t RisingEdges = 0;

// keep track of the current active LED
volatile uint8_t curr_led = RED;

int main(void){
	DisableInterrupts();
  Switch_LED_Init();
	SysTick_Init(HALF_S);
	EnableInterrupts();
	
	// initialize current active LED to be red
	LED = RED;
	curr_led = RED;
	
  while(1){
		WaitForInterrupt();
  }
}


// TODO: Initialize rising edge triggered interrupt for PF0 (SW2) and three LEDs on Port F
void Switch_LED_Init(void) {
	//onboard LEDS PF1-3
	//3 = green
	//2 = blue
	//1 = red
	
	
  
}

// TODO: Initialize SysTick timer with interrupt enabled.
// Parameter "period" specifies number of counts for the time 
void SysTick_Init(uint32_t period) {
	NVIC_ST_CTRL_R = 0;
	NVIC_ST_RELOAD_R = HALF_S - 1;
	NVIC_ST_CURRENT_R = 0;
	NVIC_SYS_PRI3_R = (NVIC_SYS_PRI3_R&0x00FFFFFF) | 0x40000000;
	NVIC_ST_CTRL_R = 0x07;
	EnableInterrupts();
}

// TODO: ISR that Handles GPIO Port F interrupts. 
// When Port F interrupt triggers, do what's necessary then increment global variable RisingEdges
void GPIOPortF_Handler(void) {
	// simple solution to take care of button debounce: 20ms to 30ms delay
  for (uint32_t i=0;i<160000;i++) {}	
}

// TODO: ISR that Handles SysTick generated interrupts. 
// When timer interrupt triggers, do what's necessary then toggle the current LED
void SysTick_Handler(void) {
	// Flash Currently Selected LED
	uint8_t curr = curr_led;
	curr_led ^= curr;
	
}
